import { renderHook, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { useAssociations } from "../../../crm/hooks/useAssociations.js";
import { fetchAssociations } from "../../../crm/utils/fetchAssociations.js";
// Mock the logger module
vi.mock('../../../logger', () => ({
    logger: {
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
    },
}));
// Mock the fetchAssociations function, keep utility functions
vi.mock('../../../crm/utils/fetchAssociations.ts', async (importOriginal) => {
    const actual = (await importOriginal());
    return {
        ...actual,
        fetchAssociations: vi.fn(),
    };
});
// Get reference to the mocked function
const mockFetchAssociations = fetchAssociations;
describe('useAssociations with Pagination', () => {
    let originalError;
    beforeAll(() => {
        // Suppress React act() warnings coming from @testing-library/react
        originalError = console.error;
        console.error = (...args) => {
            if (typeof args[0] === 'string' &&
                (args[0].includes('ReactDOMTestUtils.act') ||
                    args[0].includes('was not wrapped in act')))
                return;
            originalError.call(console, ...args);
        };
    });
    beforeEach(() => {
        // Reset the mock before each test
        mockFetchAssociations.mockReset();
    });
    afterAll(() => {
        console.error = originalError;
    });
    describe('initial state', () => {
        it('should initialize with proper pagination state', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                properties: ['firstname', 'lastname'],
                pageLength: 10,
            }));
            await waitFor(() => {
                expect(result.current.results).toEqual([]);
                expect(result.current.error).toBeNull();
                expect(result.current.isLoading).toBe(false);
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.pageSize).toBe(10);
                expect(result.current.pagination.hasNextPage).toBe(false);
                expect(result.current.pagination.hasPreviousPage).toBe(false);
            });
        });
        it('should use default page size when not specified', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                properties: ['firstname'],
            }));
            await waitFor(() => {
                expect(result.current.pagination.pageSize).toBe(10); // DEFAULT_PAGE_SIZE
            });
        });
    });
    describe('data fetching', () => {
        it('should successfully fetch and return associations with pagination info', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [
                        {
                            toObjectId: 1001,
                            associationTypes: [
                                { category: 'HUBSPOT_DEFINED', typeId: 1, label: 'Primary' },
                            ],
                            properties: {
                                firstname: 'John',
                                lastname: 'Doe',
                            },
                        },
                    ],
                    hasMore: true,
                    nextOffset: 10,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                properties: ['firstname', 'lastname'],
                pageLength: 10,
            }));
            await waitFor(() => {
                expect(result.current.results).toHaveLength(1);
                expect(result.current.results[0].toObjectId).toBe(1001);
                expect(result.current.pagination.hasNextPage).toBe(true);
                expect(result.current.pagination.hasPreviousPage).toBe(false);
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.isLoading).toBe(false);
            });
            expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining({
                toObjectType: '0-1',
                properties: ['firstname', 'lastname'],
                pageLength: 10,
                offset: undefined, // First page starts with undefined offset
            }), expect.any(Object));
        });
        it('should handle empty results correctly', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                properties: ['firstname'],
                pageLength: 5,
            }));
            await waitFor(() => {
                expect(result.current.results).toEqual([]);
                expect(result.current.pagination.hasNextPage).toBe(false);
                expect(result.current.pagination.hasPreviousPage).toBe(false);
                expect(result.current.isLoading).toBe(false);
                expect(result.current.error).toBeNull();
            });
        });
    });
    describe('pagination actions', () => {
        it('should navigate to next page correctly', async () => {
            // First page response
            mockFetchAssociations.mockResolvedValueOnce({
                data: {
                    results: [{ toObjectId: 1, associationTypes: [], properties: {} }],
                    hasMore: true,
                    nextOffset: 10,
                },
                cleanup: vi.fn(),
            });
            // Second page response
            mockFetchAssociations.mockResolvedValueOnce({
                data: {
                    results: [{ toObjectId: 2, associationTypes: [], properties: {} }],
                    hasMore: false,
                    nextOffset: 20,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                pageLength: 10,
            }));
            // Wait for initial load
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.hasNextPage).toBe(true);
            });
            // Navigate to next page
            result.current.pagination.nextPage();
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(2);
                expect(result.current.pagination.hasNextPage).toBe(false);
                expect(result.current.pagination.hasPreviousPage).toBe(true);
            });
            // Verify API was called with correct offset for page 2
            expect(mockFetchAssociations).toHaveBeenLastCalledWith(expect.objectContaining({
                offset: 10, // Uses nextOffset (10) from first page response
            }), expect.any(Object));
        });
        it('should navigate to previous page correctly', async () => {
            // First call: page 1 with hasMore: true (allows next page)
            mockFetchAssociations.mockResolvedValueOnce({
                data: {
                    results: [{ toObjectId: 1, associationTypes: [], properties: {} }],
                    hasMore: true,
                    nextOffset: 10,
                },
                cleanup: vi.fn(),
            });
            // Second call: page 2 with hasMore: false
            mockFetchAssociations.mockResolvedValueOnce({
                data: {
                    results: [{ toObjectId: 2, associationTypes: [], properties: {} }],
                    hasMore: false,
                    nextOffset: 20,
                },
                cleanup: vi.fn(),
            });
            // Third call: back to page 1
            mockFetchAssociations.mockResolvedValueOnce({
                data: {
                    results: [{ toObjectId: 1, associationTypes: [], properties: {} }],
                    hasMore: true,
                    nextOffset: 10,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                pageLength: 10,
            }));
            // Wait for initial load (page 1)
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.hasNextPage).toBe(true);
            });
            // Go to page 2
            result.current.pagination.nextPage();
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(2);
                expect(result.current.pagination.hasPreviousPage).toBe(true);
            });
            // Go back to previous page
            result.current.pagination.previousPage();
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.hasPreviousPage).toBe(false);
            });
        });
        it('should reset to first page correctly', async () => {
            // Initial page 1 - has more pages
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: true,
                    nextOffset: 10,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                pageLength: 10,
            }));
            // Wait for initial load
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.hasNextPage).toBe(true);
            });
            // Navigate to page 2, then page 3
            result.current.pagination.nextPage();
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(2);
            });
            result.current.pagination.nextPage();
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(3);
            });
            // Reset to first page
            result.current.pagination.reset();
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.hasPreviousPage).toBe(false);
            });
        });
        it('should not allow navigation beyond boundaries', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false, // No more pages
                    nextOffset: 10,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                pageLength: 10,
            }));
            await waitFor(() => {
                expect(result.current.pagination.currentPage).toBe(1);
                expect(result.current.pagination.hasNextPage).toBe(false);
            });
            // Try to go to next page when there isn't one
            result.current.pagination.nextPage();
            // Should stay on page 1
            expect(result.current.pagination.currentPage).toBe(1);
            // Try to go to previous page from page 1
            result.current.pagination.previousPage();
            // Should stay on page 1
            expect(result.current.pagination.currentPage).toBe(1);
        });
    });
    describe('error handling', () => {
        it('should handle fetch errors correctly', async () => {
            const errorMessage = 'Failed to fetch associations';
            mockFetchAssociations.mockRejectedValue(new Error(errorMessage));
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                properties: ['firstname'],
                pageLength: 10,
            }));
            await waitFor(() => {
                expect(result.current.error).toBeInstanceOf(Error);
                expect(result.current.error?.message).toBe(errorMessage);
                expect(result.current.results).toEqual([]);
                expect(result.current.isLoading).toBe(false);
            });
        });
        it('should handle null config gracefully', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            // @ts-expect-error - intentional type issue to check the failure state
            const { result } = renderHook(() => useAssociations(null));
            await waitFor(() => {
                expect(result.current.isLoading).toBe(false);
                expect(result.current.results).toEqual([]);
                expect(result.current.pagination.pageSize).toBe(10); // DEFAULT_PAGE_SIZE
            });
            expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining({
                toObjectType: undefined,
                properties: undefined,
                pageLength: 10,
                offset: undefined,
            }), expect.any(Object));
        });
        it('should handle undefined config gracefully', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            // @ts-expect-error - intentional type issue to check the failure state
            const { result } = renderHook(() => useAssociations(undefined));
            await waitFor(() => {
                expect(result.current.isLoading).toBe(false);
                expect(result.current.results).toEqual([]);
                expect(result.current.pagination.pageSize).toBe(10); // DEFAULT_PAGE_SIZE
            });
            expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining({
                toObjectType: undefined,
                properties: undefined,
                pageLength: 10,
                offset: undefined,
            }), expect.any(Object));
        });
        it('should handle empty config object gracefully', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            // @ts-expect-error - intentional type issue to check the failure state
            const { result } = renderHook(() => useAssociations({}));
            await waitFor(() => {
                expect(result.current.isLoading).toBe(false);
                expect(result.current.results).toEqual([]);
                expect(result.current.pagination.pageSize).toBe(10); // DEFAULT_PAGE_SIZE
            });
            expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining({
                toObjectType: undefined,
                properties: undefined,
                pageLength: 10,
                offset: undefined,
            }), expect.any(Object));
        });
        it('should handle config with missing toObjectType', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => 
            // @ts-expect-error - intentional type issue to check the failure state
            useAssociations({
                properties: ['firstname'],
                pageLength: 5,
            }));
            await waitFor(() => {
                expect(result.current.isLoading).toBe(false);
                expect(result.current.pagination.pageSize).toBe(5);
            });
            expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining({
                toObjectType: undefined,
                properties: ['firstname'],
                pageLength: 5,
                offset: undefined,
            }), expect.any(Object));
        });
        it('should handle config with missing properties', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const { result } = renderHook(() => useAssociations({
                toObjectType: '0-1',
                pageLength: 8,
            }));
            await waitFor(() => {
                expect(result.current.isLoading).toBe(false);
                expect(result.current.pagination.pageSize).toBe(8);
            });
            expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining({
                toObjectType: '0-1',
                properties: undefined,
                pageLength: 8,
                offset: undefined,
            }), expect.any(Object));
        });
    });
    describe('options handling', () => {
        it('should pass formatting options to fetchAssociations', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const config = {
                toObjectType: '0-1',
                properties: ['firstname', 'lastname'],
                pageLength: 10,
            };
            const options = {
                propertiesToFormat: ['firstname'],
                formattingOptions: {
                    date: {
                        format: 'MM/DD/YYYY',
                        relative: true,
                    },
                },
            };
            renderHook(() => useAssociations(config, options));
            await waitFor(() => {
                expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining(config), options);
            });
        });
        it('should use default empty options when no options provided', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const config = {
                toObjectType: '0-1',
                properties: ['firstname'],
                pageLength: 10,
            };
            renderHook(() => useAssociations(config));
            await waitFor(() => {
                expect(mockFetchAssociations).toHaveBeenCalledWith(expect.objectContaining(config), {});
            });
        });
    });
    describe('lifecycle management', () => {
        it('should call cleanup function on unmount', async () => {
            const mockCleanup = vi.fn();
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: mockCleanup,
            });
            const config = {
                toObjectType: '0-1',
                properties: ['firstname'],
                pageLength: 10,
            };
            const { unmount } = renderHook(() => useAssociations(config));
            await waitFor(() => {
                expect(mockFetchAssociations).toHaveBeenCalled();
            });
            unmount();
            await waitFor(() => {
                expect(mockCleanup).toHaveBeenCalled();
            });
        });
        it('should handle stable reference optimization for config', async () => {
            mockFetchAssociations.mockResolvedValue({
                data: {
                    results: [],
                    hasMore: false,
                    nextOffset: 0,
                },
                cleanup: vi.fn(),
            });
            const config = {
                toObjectType: '0-1',
                properties: ['firstname'],
                pageLength: 10,
            };
            const { rerender } = renderHook(({ configProp }) => useAssociations(configProp), {
                initialProps: { configProp: config },
            });
            await waitFor(() => {
                expect(mockFetchAssociations).toHaveBeenCalledTimes(1);
            });
            // Rerender with the same config object content but different reference
            rerender({ configProp: { ...config } });
            await waitFor(() => {
                // Should not call fetchAssociations again due to stable reference optimization
                expect(mockFetchAssociations).toHaveBeenCalledTimes(1);
            });
        });
    });
});
