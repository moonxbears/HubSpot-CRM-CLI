import { vi } from 'vitest';
// Set up the mock before importing the module
const mockFetchAssociations = vi.fn();
const mockSelf = {
    fetchAssociations: mockFetchAssociations,
};
// Mock the global self object
Object.defineProperty(global, 'self', {
    value: mockSelf,
    writable: true,
});
import { fetchAssociations, calculatePaginationFlags, } from "../../../crm/utils/fetchAssociations.js";
describe('fetchAssociations', () => {
    // Helper functions
    const createMockResponse = (data, overrides = {}) => ({
        ok: true,
        json: vi.fn().mockResolvedValue({ data, cleanup: vi.fn() }),
        ...overrides,
    });
    const createErrorResponse = (statusText) => ({
        ok: false,
        statusText,
        json: vi.fn().mockResolvedValue({}),
    });
    const expectError = async (request, expectedMessage) => {
        await expect(fetchAssociations(request)).rejects.toThrow(expectedMessage);
    };
    const createBasicRequest = (overrides = {}) => ({
        toObjectType: '0-1',
        properties: ['firstname', 'lastname'],
        ...overrides,
    });
    beforeEach(() => {
        vi.clearAllMocks();
        // Set up dynamic mock that responds to request parameters
        mockFetchAssociations.mockImplementation((request) => {
            const { pageLength = 100, offset = 0, properties = [] } = request;
            // Generate mock properties based on the request
            const mockProperties = {};
            properties.forEach((prop) => {
                mockProperties[prop] = `Mock ${prop} (page ${Math.floor(offset / pageLength) + 1})`;
            });
            const mockResults = [
                {
                    toObjectId: 1000 + offset,
                    associationTypes: [
                        { category: 'HUBSPOT_DEFINED', typeId: 1, label: 'Primary' },
                    ],
                    properties: mockProperties,
                },
                {
                    toObjectId: 1001 + offset,
                    associationTypes: [
                        {
                            category: 'USER_DEFINED',
                            typeId: 100,
                            label: 'Custom Association',
                        },
                    ],
                    properties: mockProperties,
                },
            ];
            const mockData = {
                results: mockResults,
                hasMore: offset < 200, // Has more until offset 200
                nextOffset: offset + pageLength,
            };
            return Promise.resolve(createMockResponse(mockData));
        });
    });
    describe('basic functionality', () => {
        it('should return mock associations with default parameters', async () => {
            const request = createBasicRequest();
            const result = await fetchAssociations(request);
            expect(result).toHaveProperty('data');
            expect(result).toHaveProperty('cleanup');
            expect(typeof result.cleanup).toBe('function');
            const { data } = result;
            expect(data.results).toHaveLength(2);
            expect(data.hasMore).toBe(true);
            expect(data.nextOffset).toBe(100);
            // Check first association
            expect(data.results[0]).toEqual({
                toObjectId: 1000,
                associationTypes: [
                    { category: 'HUBSPOT_DEFINED', typeId: 1, label: 'Primary' },
                ],
                properties: {
                    firstname: 'Mock firstname (page 1)',
                    lastname: 'Mock lastname (page 1)',
                },
            });
            // Check second association
            expect(data.results[1]).toEqual({
                toObjectId: 1001,
                associationTypes: [
                    {
                        category: 'USER_DEFINED',
                        typeId: 100,
                        label: 'Custom Association',
                    },
                ],
                properties: {
                    firstname: 'Mock firstname (page 1)',
                    lastname: 'Mock lastname (page 1)',
                },
            });
        });
        it('should return a cleanup function', async () => {
            const request = createBasicRequest({ properties: ['firstname'] });
            const result = await fetchAssociations(request);
            expect(typeof result.cleanup).toBe('function');
            // Should not throw when called
            expect(() => result.cleanup()).not.toThrow();
        });
        it('should return a Promise', () => {
            const request = createBasicRequest({ properties: ['firstname'] });
            const result = fetchAssociations(request);
            expect(result).toBeInstanceOf(Promise);
        });
    });
    describe('pagination handling', () => {
        it('should handle custom page length and offset', async () => {
            const request = createBasicRequest({
                properties: ['email'],
                pageLength: 25,
                offset: 50,
            });
            const result = await fetchAssociations(request);
            const { data } = result;
            expect(data.results).toHaveLength(2);
            expect(data.nextOffset).toBe(75); // 50 + 25
            expect(data.hasMore).toBe(true);
            // Check that offset is reflected in object IDs
            expect(data.results[0].toObjectId).toBe(1050); // 1000 + 50
            expect(data.results[1].toObjectId).toBe(1051); // 1001 + 50
            // Check that page number is reflected in properties
            expect(data.results[0].properties.email).toBe('Mock email (page 3)'); // Math.floor(50 / 25) + 1 = 3
        });
        it('should calculate hasMore correctly based on offset', async () => {
            // Test when there are more results
            const request1 = createBasicRequest({
                properties: ['firstname'],
                offset: 100,
            });
            const result1 = await fetchAssociations(request1);
            expect(result1.data.hasMore).toBe(true);
            // Test when there are no more results
            const request2 = createBasicRequest({
                properties: ['firstname'],
                offset: 200,
            });
            const result2 = await fetchAssociations(request2);
            expect(result2.data.hasMore).toBe(false);
            // Test edge case at the boundary
            const request3 = createBasicRequest({
                properties: ['firstname'],
                offset: 199,
            });
            const result3 = await fetchAssociations(request3);
            expect(result3.data.hasMore).toBe(true);
        });
        it('should generate different page numbers for different offsets', async () => {
            const request1 = createBasicRequest({
                properties: ['firstname'],
                pageLength: 10,
                offset: 0,
            });
            const result1 = await fetchAssociations(request1);
            expect(result1.data.results[0].properties.firstname).toBe('Mock firstname (page 1)');
            const request2 = createBasicRequest({
                properties: ['firstname'],
                pageLength: 10,
                offset: 20,
            });
            const result2 = await fetchAssociations(request2);
            expect(result2.data.results[0].properties.firstname).toBe('Mock firstname (page 3)'); // Math.floor(20 / 10) + 1 = 3
        });
    });
    describe('properties handling', () => {
        it('should handle empty properties array', async () => {
            const request = createBasicRequest({ properties: [] });
            const result = await fetchAssociations(request);
            const { data } = result;
            expect(data.results).toHaveLength(2);
            expect(data.results[0].properties).toEqual({});
            expect(data.results[1].properties).toEqual({});
        });
        it('should handle missing properties in request', async () => {
            const request = createBasicRequest();
            // Remove properties to test missing case
            delete request.properties;
            const result = await fetchAssociations(request);
            const { data } = result;
            expect(data.results).toHaveLength(2);
            expect(data.results[0].properties).toEqual({});
            expect(data.results[1].properties).toEqual({});
        });
        it('should handle multiple properties correctly', async () => {
            const request = createBasicRequest({
                properties: ['firstname', 'lastname', 'email', 'phone'],
            });
            const result = await fetchAssociations(request);
            const { data } = result;
            expect(data.results[0].properties).toEqual({
                firstname: 'Mock firstname (page 1)',
                lastname: 'Mock lastname (page 1)',
                email: 'Mock email (page 1)',
                phone: 'Mock phone (page 1)',
            });
        });
        it('should handle different object types', async () => {
            const request = createBasicRequest({
                toObjectType: '0-2', // Company
                properties: ['name'],
            });
            const result = await fetchAssociations(request);
            const { data } = result;
            expect(data.results).toHaveLength(2);
            expect(data.results[0].properties.name).toBe('Mock name (page 1)');
        });
    });
    describe('error handling', () => {
        it('should throw an error when response is not OK', async () => {
            mockFetchAssociations.mockResolvedValueOnce(createErrorResponse('Not Found'));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Failed to fetch associations: Not Found');
        });
        it('should throw an error when fetch fails', async () => {
            mockFetchAssociations.mockRejectedValueOnce(new Error('Network error'));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Network error');
        });
        it('should handle unknown errors', async () => {
            mockFetchAssociations.mockRejectedValueOnce('Unknown error');
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Failed to fetch associations: Unknown error');
        });
    });
    describe('response validation', () => {
        it('should throw error for invalid response format - missing results', async () => {
            const invalidData = { hasMore: true, nextOffset: 0 }; // missing results
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(invalidData));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Invalid response format');
        });
        it('should throw error for invalid response format - null data', async () => {
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(null));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Invalid response format');
        });
        it('should throw error for invalid association result structure', async () => {
            const invalidData = {
                results: [{ invalidStructure: true }], // missing required fields
                hasMore: false,
                nextOffset: 0,
            };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(invalidData));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Invalid response format');
        });
        it('should throw error for invalid association types array', async () => {
            const invalidData = {
                results: [
                    {
                        toObjectId: 1000,
                        associationTypes: 'not an array', // should be array
                        properties: {},
                    },
                ],
                hasMore: false,
                nextOffset: 0,
            };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(invalidData));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Invalid response format');
        });
        it('should throw error for missing hasMore field', async () => {
            const invalidData = {
                results: [],
                nextOffset: 0, // missing hasMore
            };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(invalidData));
            const request = createBasicRequest({ properties: ['firstname'] });
            await expectError(request, 'Invalid response format');
        });
    });
    describe('API integration', () => {
        it('should call self.fetchAssociations with correct parameters', async () => {
            const emptyData = { results: [], hasMore: false, nextOffset: 0 };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(emptyData));
            const request = createBasicRequest({
                properties: ['firstname'],
                pageLength: 50,
            });
            await fetchAssociations(request);
            expect(mockFetchAssociations).toHaveBeenCalledWith(request, undefined);
        });
        it('should return cleanup function from API response', async () => {
            const mockCleanup = vi.fn();
            const emptyData = { results: [], hasMore: false, nextOffset: 0 };
            const mockApiResponse = { data: emptyData, cleanup: mockCleanup };
            mockFetchAssociations.mockResolvedValueOnce({
                ok: true,
                json: vi.fn().mockResolvedValue(mockApiResponse),
            });
            const result = await fetchAssociations(createBasicRequest());
            expect(result.cleanup).toBe(mockCleanup);
            result.cleanup();
            expect(mockCleanup).toHaveBeenCalledTimes(1);
        });
        it('should provide default cleanup function when none provided', async () => {
            const emptyData = { results: [], hasMore: false, nextOffset: 0 };
            const mockApiResponse = { data: emptyData }; // no cleanup function provided
            mockFetchAssociations.mockResolvedValueOnce({
                ok: true,
                json: vi.fn().mockResolvedValue(mockApiResponse),
            });
            const result = await fetchAssociations(createBasicRequest());
            expect(typeof result.cleanup).toBe('function');
            expect(() => result.cleanup()).not.toThrow();
        });
        it('should successfully fetch associations with valid response', async () => {
            const validData = {
                results: [
                    {
                        toObjectId: 2000,
                        associationTypes: [
                            { category: 'HUBSPOT_DEFINED', typeId: 1, label: 'Primary' },
                        ],
                        properties: {
                            firstname: 'John',
                            lastname: 'Doe',
                        },
                    },
                ],
                hasMore: true,
                nextOffset: 100,
            };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(validData));
            const request = createBasicRequest();
            const result = await fetchAssociations(request);
            expect(mockFetchAssociations).toHaveBeenCalledWith(request, undefined);
            expect(result.data).toEqual(validData);
            expect(typeof result.cleanup).toBe('function');
        });
    });
    describe('options handling', () => {
        it('should pass formatting options to the underlying fetch function', async () => {
            const emptyData = { results: [], hasMore: false, nextOffset: 0 };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(emptyData));
            const options = {
                propertiesToFormat: ['firstname'],
                formattingOptions: {
                    date: { format: 'MM/dd/yyyy' },
                    currency: { addSymbol: true },
                },
            };
            const request = createBasicRequest();
            await fetchAssociations(request, options);
            expect(mockFetchAssociations).toHaveBeenCalledWith(request, options);
        });
        it('should handle propertiesToFormat set to "all"', async () => {
            const emptyData = { results: [], hasMore: false, nextOffset: 0 };
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse(emptyData));
            const options = {
                propertiesToFormat: 'all',
                formattingOptions: {
                    dateTime: { relative: true },
                },
            };
            const request = createBasicRequest();
            await fetchAssociations(request, options);
            expect(mockFetchAssociations).toHaveBeenCalledWith(request, options);
        });
        it('should preserve error handling with formatting options', async () => {
            mockFetchAssociations.mockRejectedValueOnce(new Error('Network error'));
            const options = {
                propertiesToFormat: ['firstname'],
                formattingOptions: {
                    date: { format: 'MM/dd/yyyy' },
                },
            };
            const request = createBasicRequest({ properties: ['firstname'] });
            await expect(fetchAssociations(request, options)).rejects.toThrow('Network error');
            expect(mockFetchAssociations).toHaveBeenCalledWith(request, options);
        });
        it('should preserve response validation with formatting options', async () => {
            mockFetchAssociations.mockResolvedValueOnce(createMockResponse('Invalid response')); // data should be an object
            const options = {
                propertiesToFormat: 'all',
            };
            const request = createBasicRequest({ properties: ['firstname'] });
            await expect(fetchAssociations(request, options)).rejects.toThrow('Invalid response format');
        });
    });
    describe('pagination utilities', () => {
        describe('calculatePaginationFlags', () => {
            it('should calculate pagination flags correctly', () => {
                // Page 1 scenarios
                expect(calculatePaginationFlags(1, true)).toEqual({
                    hasNextPage: true,
                    hasPreviousPage: false,
                });
                expect(calculatePaginationFlags(1, false)).toEqual({
                    hasNextPage: false,
                    hasPreviousPage: false,
                });
                // Page 2+ scenarios
                expect(calculatePaginationFlags(2, true)).toEqual({
                    hasNextPage: true,
                    hasPreviousPage: true,
                });
                expect(calculatePaginationFlags(2, false)).toEqual({
                    hasNextPage: false,
                    hasPreviousPage: true,
                });
            });
        });
    });
});
