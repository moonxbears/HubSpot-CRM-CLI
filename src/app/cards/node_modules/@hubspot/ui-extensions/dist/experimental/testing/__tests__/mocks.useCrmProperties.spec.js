import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Text } from "../../../index.js";
import { createRenderer } from "../index.js";
import { useCrmProperties } from "../../../crm/index.js";
function MyComponent() {
    const { properties, isLoading, error } = useCrmProperties([
        'firstname',
        'lastname',
    ]);
    if (isLoading) {
        return _jsx(Text, { children: "Loading..." });
    }
    if (error) {
        return _jsx(Text, { children: "Something went wrong!" });
    }
    return (_jsxs(_Fragment, { children: [_jsxs(Text, { children: ["First name: ", properties.firstname] }), _jsxs(Text, { children: ["Last name: ", properties.lastname] })] }));
}
describe('mock useCrmProperties', () => {
    it('should provide a default mock implementation', () => {
        const { render } = createRenderer('crm.record.tab');
        const { findAll } = render(_jsx(MyComponent, {}));
        const textNodes = findAll(Text);
        expect(textNodes.length).toEqual(2);
        expect(textNodes[0].text).toEqual('First name: fake_firstname');
        expect(textNodes[1].text).toEqual('Last name: fake_lastname');
    });
    it('should allow mocking the next function result', () => {
        const { render, mocks } = createRenderer('crm.record.tab');
        mocks.useCrmProperties.nextResult({
            properties: {},
            error: new Error('Something went wrong!'),
            isLoading: false,
        });
        const { find } = render(_jsx(MyComponent, {}));
        expect(find(Text).text).toEqual('Something went wrong!');
    });
    it('should allow providing a custom mock function', () => {
        const { render, mocks, findAll } = createRenderer('crm.record.tab');
        mocks.useCrmProperties.willCall((propertyNames) => {
            const properties = propertyNames.reduce((acc, propertyName) => {
                acc[propertyName] = propertyName.toUpperCase();
                return acc;
            }, {});
            return {
                properties,
                error: null,
                isLoading: false,
            };
        });
        render(_jsx(MyComponent, {}));
        const textNodes = findAll(Text);
        const firstNameText = textNodes[0];
        const lastNameText = textNodes[1];
        expect(firstNameText.isMatch(Text) && firstNameText.text).toEqual('First name: FIRSTNAME');
        expect(lastNameText.isMatch(Text) && lastNameText.text).toEqual('Last name: LASTNAME');
    });
});
