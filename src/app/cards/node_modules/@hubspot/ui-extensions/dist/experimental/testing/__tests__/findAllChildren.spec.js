import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Alert, Button, ButtonRow, Text } from "../../../index.js";
import { createRenderer } from "../index.js";
describe('findAllChildren()', () => {
    it('should allow finding all direct children from the root node', () => {
        const { render, findAllChildren } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsxs(ButtonRow, { children: [_jsx(Button, { variant: "secondary", children: "Button 1" }), _jsx(Button, { variant: "primary", children: "Button 2" })] }), _jsx(Alert, { title: "My Alert" }), _jsx(Alert, { title: "Another Alert" })] }));
        const alerts = findAllChildren(Alert);
        expect(alerts).toHaveLength(2);
        expect(alerts[0]?.props).toMatchObject({ title: 'My Alert' });
        expect(alerts[1]?.props).toMatchObject({ title: 'Another Alert' });
    });
    it('should only find direct children, not nested descendants', () => {
        const { render, findAllChildren } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsxs(ButtonRow, { children: [_jsx(Button, { variant: "secondary", children: "Button 1" }), _jsx(Button, { variant: "primary", children: "Button 2" })] }), _jsx(Alert, { title: "My Alert" })] }));
        const buttons = findAllChildren(Button);
        expect(buttons).toHaveLength(0);
    });
    it('should allow finding all direct children from a nested component', () => {
        const { render, find } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsxs(ButtonRow, { children: [_jsx(Button, { variant: "secondary", children: "Button 1" }), _jsx(Button, { variant: "primary", children: "Button 2" })] }), _jsx(Alert, { title: "My Alert" })] }));
        const buttonRow = find(ButtonRow);
        const buttons = buttonRow.findAllChildren(Button);
        expect(buttons).toHaveLength(2);
        expect(buttons[0]?.props).toMatchObject({ variant: 'secondary' });
        expect(buttons[1]?.props).toMatchObject({ variant: 'primary' });
    });
    it('should return empty array when no direct children match', () => {
        const { render, findAllChildren } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", children: "Button 1" }) }) }));
        const texts = findAllChildren(Text);
        expect(texts).toHaveLength(0);
    });
    it('should support matcher function', () => {
        const { render, find } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsxs(ButtonRow, { children: [_jsx(Button, { variant: "secondary", children: "Button 1" }), _jsx(Button, { variant: "primary", children: "Button 2" }), _jsx(Button, { variant: "secondary", children: "Button 3" })] }) }));
        const buttonRow = find(ButtonRow);
        const secondaryButtons = buttonRow.findAllChildren(Button, (node) => node.props.variant === 'secondary');
        expect(secondaryButtons).toHaveLength(2);
        expect(secondaryButtons[0]?.props).toMatchObject({ variant: 'secondary' });
        expect(secondaryButtons[1]?.props).toMatchObject({ variant: 'secondary' });
    });
    it('should support matcher object', () => {
        const { render, find } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsxs(ButtonRow, { children: [_jsx(Button, { variant: "secondary", children: "Button 1" }), _jsx(Button, { variant: "primary", children: "Button 2" }), _jsx(Button, { variant: "secondary", children: "Button 3" })] }) }));
        const buttonRow = find(ButtonRow);
        const primaryButtons = buttonRow.findAllChildren(Button, {
            variant: 'primary',
        });
        expect(primaryButtons).toHaveLength(1);
        expect(primaryButtons[0]?.props).toMatchObject({ variant: 'primary' });
    });
});
