import { RenderedElementNode, RenderedParentNode } from '../types.ts';
import { RenderedRootNodeInternal } from './types-internal.ts';
/**
 * Thrown when trying to trigger an event that has a handler prop that is not a function.
 */
export declare class InvalidEventFunctionError extends Error {
    constructor({ componentName, eventPropName, }: {
        componentName: string;
        eventPropName: string;
    });
}
/**
 * Thrown when trying to trigger an event that has no corresponding handler function in the props object.
 */
export declare class MissingEventFunctionError extends Error {
    constructor({ componentName, eventPropName, }: {
        componentName: string;
        eventPropName: string;
    });
}
/**
 * Thrown when a component is not found in the rendered output.
 */
export declare class ComponentNotFoundError extends Error {
    constructor({ findMethodName, parentNode, componentName, }: {
        findMethodName: string;
        parentNode: RenderedParentNode;
        componentName: string;
    });
}
/**
 * Thrown when invalid components are detected in the rendered output.
 */
export declare class InvalidComponentsError extends Error {
    constructor(rootNode: RenderedRootNodeInternal);
}
/**
 * Thrown when the target component passed to the find operation is not a valid HubSpot-provided React component.
 */
export declare class FindInvalidComponentError extends Error {
    constructor({ findMethodName }: {
        findMethodName: string;
    });
}
/**
 * Thrown when a fragment prop array is detected in the rendered output.
 */
export declare class InvalidFragmentPropArrayError extends Error {
    constructor(componentName: string, propName: string);
}
/**
 * Thrown when a waitFor() check doesn't pass within the timeout period.
 */
export declare class WaitForTimeoutError extends Error {
    constructor(timeout: number);
}
/**
 * Thrown when an invalid extension point location is provided.
 */
export declare class InvalidExtensionPointLocationError extends Error {
    constructor(extensionPointLocation: string);
}
/**
 * Thrown when a component is not found in the rendered output when queryingby test ID.
 */
export declare class ComponentNotFoundByTestIdError extends Error {
    constructor({ findMethodName, componentName, testId, rootNode, }: {
        findMethodName: string;
        componentName: string;
        testId: string;
        rootNode: RenderedRootNodeInternal;
    });
}
/**
 * Thrown when a component is found in the rendered output when querying by test ID, but does not match the expected component.
 */
export declare class ComponentMismatchedByTestIdError extends Error {
    constructor({ findMethodName, actualComponentName, expectedComponentName, testId, rootNode, }: {
        findMethodName: string;
        actualComponentName: string;
        expectedComponentName: string;
        testId: string;
        rootNode: RenderedRootNodeInternal;
    });
}
/**
 * Thrown when a test ID is already in use.
 *
 * @param testId The test ID that is already in use.
 * @param previousElement The element that was already using the test ID.
 * @param newElement The element that is trying to use the same test ID.
 */
export declare class DuplicateTestIdError extends Error {
    constructor({ testId, previousElement, newElement, }: {
        testId: string;
        previousElement: RenderedElementNode;
        newElement: RenderedElementNode;
    });
}
