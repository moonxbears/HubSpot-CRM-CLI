import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Alert, Button, ButtonRow, Text } from "../../../index.js";
import { createRenderer } from "../index.js";
describe('maybeFindChild()', () => {
    it('should return direct child from the root node', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", children: "Button 1" }) }), _jsx(Alert, { title: "My Alert" })] }));
        const alert = maybeFindChild(Alert);
        expect(alert).toBeDefined();
        expect(alert?.props).toEqual({ title: 'My Alert' });
    });
    it('should return null when direct child is not found', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", children: "Button 1" }) }) }));
        const text = maybeFindChild(Text);
        expect(text).toBeNull();
    });
    it('should only find direct children, not nested descendants', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", children: "Button 1" }) }), _jsx(Alert, { title: "My Alert" })] }));
        const button = maybeFindChild(Button);
        expect(button).toBeNull();
    });
    it('should return first direct child when multiple children match', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Alert, { title: "First Alert" }), _jsx(Alert, { title: "Second Alert" }), _jsx(Alert, { title: "Third Alert" })] }));
        const alert = maybeFindChild(Alert);
        expect(alert).toBeDefined();
        expect(alert?.props).toMatchObject({ title: 'First Alert' });
    });
    it('should support matcher function', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Alert, { title: "First Alert" }), _jsx(Alert, { title: "Second Alert" })] }));
        const secondAlert = maybeFindChild(Alert, (node) => node.props.title === 'Second Alert');
        expect(secondAlert).toBeDefined();
        expect(secondAlert?.props).toMatchObject({ title: 'Second Alert' });
    });
    it('should return null when matcher function does not match any children', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Alert, { title: "First Alert" }), _jsx(Alert, { title: "Second Alert" })] }));
        const thirdAlert = maybeFindChild(Alert, (node) => node.props.title === 'Third Alert');
        expect(thirdAlert).toBeNull();
    });
    it('should support matcher object', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Alert, { title: "First Alert" }), _jsx(Alert, { title: "Second Alert" })] }));
        const secondAlert = maybeFindChild(Alert, { title: 'Second Alert' });
        expect(secondAlert).toBeDefined();
        expect(secondAlert?.props).toMatchObject({ title: 'Second Alert' });
    });
    it('should return null when matcher object does not match any children', () => {
        const { render, maybeFindChild } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Alert, { title: "First Alert" }), _jsx(Alert, { title: "Second Alert" })] }));
        const thirdAlert = maybeFindChild(Alert, { title: 'Third Alert' });
        expect(thirdAlert).toBeNull();
    });
    it('should work on nested element nodes', () => {
        const { render, find } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsxs(ButtonRow, { children: [_jsx(Button, { variant: "primary", children: "Button 1" }), _jsx(Button, { variant: "secondary", children: "Button 2" })] }) }));
        const buttonRow = find(ButtonRow);
        const primaryButton = buttonRow.maybeFindChild(Button, {
            variant: 'primary',
        });
        expect(primaryButton).toBeDefined();
        expect(primaryButton?.props).toMatchObject({ variant: 'primary' });
    });
    it('should return null on nested element when child not found', () => {
        const { render, find } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(ButtonRow, { children: _jsx(Button, { variant: "secondary", children: "Button 1" }) }) }));
        const buttonRow = find(ButtonRow);
        const text = buttonRow.maybeFindChild(Text);
        expect(text).toBeNull();
    });
});
