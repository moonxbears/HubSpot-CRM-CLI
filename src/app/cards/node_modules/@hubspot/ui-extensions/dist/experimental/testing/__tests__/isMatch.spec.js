import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Alert, Button } from "../../../index.js";
import { createRenderer, isMatch, isRenderedFragmentNode, } from "../index.js";
describe('isMatch()', () => {
    describe('isMatch() utility function', () => {
        it('should allow assertions against a mix of text and element nodes', () => {
            const { render, getRootNode } = createRenderer('crm.record.tab');
            render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", children: "Click me!" }), _jsx(Alert, { title: "My Alert" }), "Hello"] }));
            const rootNode = getRootNode();
            const { childNodes } = rootNode;
            const buttonNode = childNodes[0];
            const alertNode = childNodes[1];
            const textNode = childNodes[2];
            if (isMatch(buttonNode, Button)) {
                expect(buttonNode.props.variant).toEqual('primary');
            }
            else {
                throw new Error('Expected button node');
            }
            expect(isMatch(alertNode, Button)).toBe(false);
            expect(isMatch(textNode, Button)).toBe(false);
        });
        it('should allow a custom matcher function to be provided', () => {
            const { render, getRootNode } = createRenderer('crm.record.tab');
            render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", children: "Primary" }), _jsx(Button, { variant: "secondary", children: "Secondary" }), _jsx(Alert, { title: "My Alert" }), "Hello"] }));
            const rootNode = getRootNode();
            const { childNodes } = rootNode;
            const primaryButtonNode = childNodes[0];
            const secondaryButtonNode = childNodes[1];
            const alertNode = childNodes[2];
            const textNode = childNodes[3];
            const matcher = (node) => node.props.variant === 'primary';
            if (isMatch(primaryButtonNode, Button, matcher)) {
                expect(primaryButtonNode.props.variant).toEqual('primary');
            }
            else {
                throw new Error('Expected button node');
            }
            expect(isMatch(secondaryButtonNode, Button, matcher)).toBe(false);
            expect(isMatch(alertNode, Button, matcher)).toBe(false);
            expect(isMatch(textNode, Button, matcher)).toBe(false);
        });
        it('should allow a partial props object to be provided for matching', () => {
            const { render, getRootNode } = createRenderer('crm.record.tab');
            render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", children: "Primary" }), _jsx(Button, { variant: "secondary", children: "Secondary" }), _jsx(Alert, { title: "My Alert" }), "Hello"] }));
            const rootNode = getRootNode();
            const { childNodes } = rootNode;
            const primaryButtonNode = childNodes[0];
            const secondaryButtonNode = childNodes[1];
            const alertNode = childNodes[2];
            const textNode = childNodes[3];
            const matcher = { variant: 'primary' };
            if (isMatch(primaryButtonNode, Button, matcher)) {
                expect(primaryButtonNode.props.variant).toEqual('primary');
            }
            else {
                throw new Error('Expected button node');
            }
            expect(isMatch(secondaryButtonNode, Button, matcher)).toBe(false);
            expect(isMatch(alertNode, Button, matcher)).toBe(false);
            expect(isMatch(textNode, Button, matcher)).toBe(false);
        });
    });
    describe('RenderedText.isMatch()', () => {
        it('should work correctly for text nodes', () => {
            const { render, find } = createRenderer('crm.record.tab');
            render(_jsx(Button, { variant: "primary", children: "Primary" }));
            const buttonNode = find(Button);
            const textNode = buttonNode.childNodes[0];
            expect(textNode.isMatch(Button)).toBe(false);
            expect(textNode.isMatch(Button) && textNode.props.variant === 'primary').toBe(false);
        });
    });
    describe('RenderedElement.isMatch()', () => {
        it('should work correctly for element nodes', () => {
            const { render, find } = createRenderer('crm.record.tab');
            render(_jsx(Button, { variant: "primary", children: "Primary" }));
            const buttonNode = find(Button);
            expect(buttonNode.isMatch(Button)).toBe(true);
        });
        it('should work correctly for element nodes with a custom matcher function', () => {
            const { render, find } = createRenderer('crm.record.tab');
            render(_jsx(Button, { variant: "primary", children: "Primary" }));
            const buttonNode = find(Button);
            expect(buttonNode.isMatch(Button, (node) => node.props.variant === 'primary')).toBe(true);
        });
        it('should work correctly for element nodes with a partial props object', () => {
            const { render, find } = createRenderer('crm.record.tab');
            render(_jsx(Button, { variant: "primary", children: "Primary" }));
            const buttonNode = find(Button);
            expect(buttonNode.isMatch(Button, { variant: 'primary' })).toBe(true);
        });
    });
    describe('RenderedFragment.isMatch()', () => {
        it('should work correctly for fragment nodes', () => {
            const { render, find } = createRenderer('crm.record.tab');
            render(_jsx(Button, { variant: "primary", overlay: _jsx(_Fragment, { children: "My Overlay" }), children: "Hello" }));
            const buttonNode = find(Button);
            const overlayFragmentNode = buttonNode.props.overlay;
            expect(isRenderedFragmentNode(overlayFragmentNode)).toBe(true);
            expect(overlayFragmentNode.isMatch(Button)).toBe(false);
        });
    });
    describe('RenderedRoot.isMatch()', () => {
        it('should work correctly for root nodes', () => {
            const { render, getRootNode } = createRenderer('crm.record.tab');
            render(_jsx(Button, { variant: "primary", children: "Primary" }));
            const rootNode = getRootNode();
            expect(rootNode.isMatch(Button)).toBe(false);
        });
    });
});
