import { EXTENSION_POINT_LOCATIONS } from "../../../shared/types/extension-points.js";
import { printNode } from "./print.js";
import { asRenderedNode } from "./type-utils-internal.js";
/**
 * Thrown when trying to trigger an event that has a handler prop that is not a function.
 */
export class InvalidEventFunctionError extends Error {
    constructor({ componentName, eventPropName, }) {
        super(`trigger("${String(eventPropName)}", ...) failed. Event function for prop "${String(eventPropName)}" in component "${componentName}" props is not a function`);
        this.name = 'InvalidEventFunctionError';
    }
}
/**
 * Thrown when trying to trigger an event that has no corresponding handler function in the props object.
 */
export class MissingEventFunctionError extends Error {
    constructor({ componentName, eventPropName, }) {
        super(`trigger("${String(eventPropName)}", ...) failed. Event function for prop "${String(eventPropName)}" not found in component "${componentName}" props`);
        this.name = 'MissingEventFunctionError';
    }
}
/**
 * Thrown when a component is not found in the rendered output.
 */
export class ComponentNotFoundError extends Error {
    constructor({ findMethodName, parentNode, componentName, }) {
        super(`${findMethodName}() failed. <${componentName}> not found in rendered output: ${parentNode.toString()}`);
        this.name = 'ComponentNotFoundError';
    }
}
/**
 * Thrown when invalid components are detected in the rendered output.
 */
export class InvalidComponentsError extends Error {
    constructor(rootNode) {
        super(`Invalid rendered output. Found invalid components (${rootNode.document
            .getInvalidComponentNames()
            .map((name) => `"${name}"`)
            .join(', ')}) in rendered output: ${printNode(asRenderedNode(rootNode), {
            markInvalidComponents: true,
            listInvalidComponents: true,
        })}`);
        this.name = 'InvalidComponentsError';
    }
}
/**
 * Thrown when the target component passed to the find operation is not a valid HubSpot-provided React component.
 */
export class FindInvalidComponentError extends Error {
    constructor({ findMethodName }) {
        super(`${findMethodName}() failed. The provided target component is not a HubSpot-provided React component`);
        this.name = 'FindInvalidComponentError';
    }
}
/**
 * Thrown when a fragment prop array is detected in the rendered output.
 */
export class InvalidFragmentPropArrayError extends Error {
    constructor(componentName, propName) {
        super(`Invalid rendered output. Invalid fragment prop array ${propName} for component ${componentName}. Arrays are not allowed for fragment props.`);
        this.name = 'InvalidFragmentPropArrayError';
    }
}
/**
 * Thrown when a waitFor() check doesn't pass within the timeout period.
 */
export class WaitForTimeoutError extends Error {
    constructor(timeout) {
        super(`waitFor() failed. Timeout of ${timeout}ms exceeded waiting for check to pass`);
        this.name = 'WaitForTimeoutError';
    }
}
/**
 * Thrown when an invalid extension point location is provided.
 */
export class InvalidExtensionPointLocationError extends Error {
    constructor(extensionPointLocation) {
        super(`Invalid extension point location of "${extensionPointLocation}". Allowed locations are: ${EXTENSION_POINT_LOCATIONS.map((location) => `"${location}"`).join(', ')}`);
        this.name = 'InvalidExtensionPointLocationError';
    }
}
/**
 * Thrown when a component is not found in the rendered output when queryingby test ID.
 */
export class ComponentNotFoundByTestIdError extends Error {
    constructor({ findMethodName, componentName, testId, rootNode, }) {
        super(`${findMethodName}() failed. <${componentName}> with test ID "${testId}" not found in rendered output: ${rootNode.toString()}`);
        this.name = 'ComponentNotFoundByTestIdError';
    }
}
/**
 * Thrown when a component is found in the rendered output when querying by test ID, but does not match the expected component.
 */
export class ComponentMismatchedByTestIdError extends Error {
    constructor({ findMethodName, actualComponentName, expectedComponentName, testId, rootNode, }) {
        super(`${findMethodName}() failed. <${actualComponentName}> with test ID "${testId}" does not match expected component <${expectedComponentName}> in rendered output: ${rootNode.toString()}`);
        this.name = 'ComponentMismatchedByTestIdError';
    }
}
/**
 * Thrown when a test ID is already in use.
 *
 * @param testId The test ID that is already in use.
 * @param previousElement The element that was already using the test ID.
 * @param newElement The element that is trying to use the same test ID.
 */
export class DuplicateTestIdError extends Error {
    constructor({ testId, previousElement, newElement, }) {
        super(`Test ID "${testId}" is already in use.\n\nPrevious component: ${previousElement.toString()}\n\nNew component: ${newElement.toString()}`);
        this.name = 'DuplicateTestIdError';
    }
}
