import { jsx as _jsx } from "react/jsx-runtime";
import { createRemoteRoot } from '@remote-ui/core';
import { createRoot as createReactRoot } from '@remote-ui/react';
import { convertRemoteRoot } from "./internal/convert.js";
import { createDocument } from "./internal/document.js";
import { InvalidComponentsError, InvalidExtensionPointLocationError, WaitForTimeoutError, } from "./internal/errors.js";
import { EXTENSION_POINT_LOCATIONS, } from "../../shared/types/extension-points.js";
import { MocksContextProvider } from "../../internal/hook-utils.js";
import { createMocksWithSpies } from "./internal/mocks/index.js";
import { find, findAll, findAllChildren, findByTestId, findChild, maybeFind, maybeFindByTestId, maybeFindChild, } from "./internal/query.js";
import { createRootNode } from "./internal/root.js";
import { asRenderedRootNode } from "./internal/type-utils-internal.js";
import { createDeferred, } from "./internal/utils/promise-utils.js";
const DEFAULT_WAIT_FOR_TIMEOUT_IN_MS = 1000;
const DEFAULT_WAIT_FOR_OPTIONS = {
    timeoutInMs: DEFAULT_WAIT_FOR_TIMEOUT_IN_MS,
};
/**
 * Renders a UI extension component using React so that assertions can be made against the rendered output.
 *
 * @param node The React node to render.
 * @returns A render result object
 */
const render = (node, mocks) => {
    let dirty = true;
    let waitForChecksQueued = false;
    let waitForList = [];
    const runWaitForChecks = () => {
        waitForChecksQueued = false;
        waitForList = waitForList.filter((waitFor) => {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            const renderedRootNode = getLatestRootNode();
            if (renderedRootNode.document.hasInvalidComponentNames()) {
                // Reject the waitFor promise if we detect invalid components in the rendered output.
                waitFor.deferred.reject(new InvalidComponentsError(renderedRootNode));
                if (waitFor.setTimeoutId) {
                    // Clear the timeout so that we don't reject the promise if the check passes before the timeout expires.
                    // Technically, calling reject on a promise that has already been resolved is a no-op.
                    clearTimeout(waitFor.setTimeoutId);
                }
                return false;
            }
            try {
                waitFor.check(); // Run the user provided check function.
                if (waitFor.setTimeoutId) {
                    // Clear the timeout so that we don't reject the promise if the check passes before the timeout expires.
                    // Technically, calling reject on a promise that has already been resolved is a no-op.
                    clearTimeout(waitFor.setTimeoutId);
                }
                waitFor.deferred.resolve(); // Resolve the promise that was originally returned by the waitFor function.
                return false; // Remove the waitFor from the list since the check passed and we resolved the promise
            }
            catch (error) {
                return true; // Keep the waitFor in the list since the check failed and we didn't resolve the promise.
            }
        });
    };
    /**
     * This function will be invoked any time there are changes to the remote DOM.
     * We don't really care what the changes were because we are not actually sending them
     * to a host page. We are only interested in the fact that the DOM has been updated
     * so that we can know that we need rebuild our own tree of rendered nodes.
     */
    const remoteChannel = () => {
        dirty = true;
        if (waitForList.length > 0) {
            // Even though @remote-ui/core is notifying us that the DOM has been updated, it hasn't actually
            // applied the DOMs to the remote DOM representation. Therefore, we need to queue a microtask to
            // run the waitFor checks at the end of the event loop to give the DOM a chance to be updated...
            if (!waitForChecksQueued) {
                waitForChecksQueued = true;
                queueMicrotask(runWaitForChecks);
            }
        }
    };
    const remoteRoot = createRemoteRoot(remoteChannel);
    const reactRoot = createReactRoot(remoteRoot);
    reactRoot.render(_jsx(MocksContextProvider, { value: mocks, children: node }));
    remoteRoot.mount();
    let maybeRenderedRootNode;
    /**
     * Returns the latest rendered root node. If the root node has not been rendered yet, it will be rendered.
     * If there were no changes to the remote DOM then the previously rendered root node will be returned.
     */
    const getLatestRootNode = () => {
        if (maybeRenderedRootNode && !dirty) {
            // Return the previously rendered root node if there were no changes to the remote DOM.
            return maybeRenderedRootNode;
        }
        // Create a new document for the next rendered DOM tree
        const document = createDocument({
            getLatestRootNode,
        });
        const nextRootNode = createRootNode(document);
        document.rootNode = nextRootNode;
        // Convert the tree of remote nodes to a tree of rendered nodes.
        convertRemoteRoot(nextRootNode, remoteRoot);
        maybeRenderedRootNode = nextRootNode;
        dirty = false;
        return maybeRenderedRootNode;
    };
    const initialRenderedRootNode = getLatestRootNode();
    if (initialRenderedRootNode.document.hasInvalidComponentNames()) {
        throw new InvalidComponentsError(initialRenderedRootNode);
    }
    return {
        getLatestRootNode,
        waitFor: (check, options = DEFAULT_WAIT_FOR_OPTIONS) => {
            const { timeoutInMs = DEFAULT_WAIT_FOR_TIMEOUT_IN_MS } = options;
            try {
                check();
                // Nothing to wait for since the check passed! Resolve the promise immediately.
                return Promise.resolve();
            }
            catch (error) {
                // If the check failed then we need to put it in the waitForList so that we
                // can check it again later. We return a promise that will be resolved when
                // the provided check passes.
            }
            const deferred = createDeferred();
            const waitFor = { check, deferred, setTimeoutId: null };
            waitForList.push(waitFor);
            if (timeoutInMs > 0) {
                waitFor.setTimeoutId = setTimeout(() => {
                    // Remove the wait for from the list since the timeout expired and we rejected the promise.
                    waitForList = waitForList.filter((currentWaitFor) => currentWaitFor !== waitFor);
                    deferred.reject(new WaitForTimeoutError(timeoutInMs));
                }, timeoutInMs);
            }
            return deferred.promise;
        },
    };
};
/**
 * Creates a renderer object with methods for rendering and testing UI extension components.
 * Mocks for supported React hooks and the Extension Point API are automatically provided based on the extension point location.
 *
 * Example usage:
 *
 * ```tsx
 * import { createRenderer } from '@hubspot/ui-extensions/testing';
 * import { Alert, Button, ButtonRow } from '@hubspot/ui-extensions';
 *
 * const { render, find } = createRenderer('crm.record.tab');
 * render(
 *   <>
 *   <ButtonRow>
 *     <Button variant="secondary">Button 1</Button>
 *     <Button variant="primary">Button 2</Button>
 *   </ButtonRow>
 *   <Alert title="My Alert" />
 * </>
 * );
 *
 * // Find any button
 * const button = find(Button);
 *
 * // Assertions
 * expect(button.props.variant).toEqual('primary');
 * expect(button.text).toEqual('Button 2');
 * ```
 *
 * @param extensionPointLocation The extension point location.
 * @returns A renderer object with methods for rendering and testing UI extension components.
 */
export const createRenderer = (extensionPointLocation) => {
    if (!EXTENSION_POINT_LOCATIONS.includes(extensionPointLocation)) {
        throw new InvalidExtensionPointLocationError(extensionPointLocation);
    }
    let renderResult = null;
    const getRenderResult = () => {
        if (!renderResult) {
            throw new Error('Renderer not initialized');
        }
        return renderResult;
    };
    const getLatestRootNode = () => getRenderResult().getLatestRootNode();
    const { mocks, spies } = createMocksWithSpies(extensionPointLocation);
    return {
        render: (node) => {
            renderResult = render(node, mocks);
            return asRenderedRootNode(renderResult.getLatestRootNode());
        },
        mocks: spies,
        find: (component, matcher) => {
            return find(getLatestRootNode(), component, matcher);
        },
        findAll: (component, matcher) => {
            return findAll(getLatestRootNode(), component, matcher);
        },
        findChild: (component, matcher) => {
            return findChild(getLatestRootNode(), component, matcher);
        },
        findAllChildren: (component, matcher) => {
            return findAllChildren(getLatestRootNode(), component, matcher);
        },
        maybeFindChild: (component, matcher) => {
            return maybeFindChild(getLatestRootNode(), component, matcher);
        },
        maybeFind: (component, matcher) => {
            return maybeFind(getLatestRootNode(), component, matcher);
        },
        findByTestId: (component, testId) => {
            return findByTestId(getLatestRootNode().document, component, testId);
        },
        maybeFindByTestId: (component, testId) => {
            return maybeFindByTestId(getLatestRootNode().document, component, testId);
        },
        waitFor: (check, options = DEFAULT_WAIT_FOR_OPTIONS) => {
            return getRenderResult().waitFor(check, options);
        },
        debugLog: (label) => {
            return getLatestRootNode().debugLog(label);
        },
        getRootNode: () => {
            return asRenderedRootNode(getLatestRootNode());
        },
    };
};
