import { renderHook, waitFor } from '@testing-library/react';
import { vi } from 'vitest';
import { useCrmProperties } from "../../../crm/hooks/useCrmProperties.js";
import * as fetchCrmPropertiesModule from "../../../crm/utils/fetchCrmProperties.js";
// Mock the logger module
vi.mock('../../../logger', () => ({
    logger: {
        debug: vi.fn(),
        info: vi.fn(),
        warn: vi.fn(),
        error: vi.fn(),
    },
}));
// Mock the fetchCrmProperties module
vi.mock('../../../crm/utils/fetchCrmProperties');
const mockFetchCrmProperties = vi.fn();
fetchCrmPropertiesModule.fetchCrmProperties = mockFetchCrmProperties;
describe('useCrmProperties', () => {
    let originalError;
    beforeAll(() => {
        // Suppress React act() warning coming from @testing-library/react
        originalError = console.error;
        console.error = (...args) => {
            if (args[0]?.includes('ReactDOMTestUtils.act'))
                return;
            originalError.call(console, ...args);
        };
    });
    beforeEach(() => {
        // Reset the mock before each test
        mockFetchCrmProperties.mockReset();
    });
    afterAll(() => {
        console.error = originalError;
    });
    it('should return the initial values for properties, error, and isLoading', async () => {
        const { result } = renderHook(() => useCrmProperties(['firstname', 'lastname']));
        await waitFor(() => {
            expect(result.current.properties).toEqual({});
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(true);
        });
    });
    it('should successfully fetch and return CRM properties', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            });
            expect(result.current.error).toBeNull();
            expect(result.current.isLoading).toBe(false);
        });
    });
    it('should handle fetch errors correctly', async () => {
        const errorMessage = 'Failed to fetch CRM properties';
        mockFetchCrmProperties.mockRejectedValue(new Error(errorMessage));
        const propertyNames = ['firstname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(result.current.error?.message).toBe(errorMessage);
            expect(result.current.properties).toEqual({});
            expect(result.current.isLoading).toBe(false);
        });
    });
    it('should update properties when propertiesUpdatedCallback is called', async () => {
        // Capture the callback so we can simulate an external update to CRM properties
        let capturedCallback;
        mockFetchCrmProperties.mockImplementation((_propertyNames, propertiesUpdatedCallback) => {
            capturedCallback = propertiesUpdatedCallback;
            return {
                data: { firstname: 'Initial', lastname: 'Initial' },
                cleanup: vi.fn(),
            };
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Initial',
                lastname: 'Initial',
            });
            expect(result.current.isLoading).toBe(false);
        });
        const updatedProperties = { firstname: 'Updated', lastname: 'Updated' };
        await waitFor(() => {
            if (capturedCallback) {
                capturedCallback?.(updatedProperties);
                expect(result.current.properties).toEqual(updatedProperties);
            }
        });
    });
    it('should update properties when propertiesUpdatedCallback is called with null values', async () => {
        // Capture the callback so we can simulate an external update to CRM properties
        let capturedCallback;
        mockFetchCrmProperties.mockImplementation((_propertyNames, propertiesUpdatedCallback) => {
            capturedCallback = propertiesUpdatedCallback;
            return {
                data: { firstname: 'Initial', lastname: null },
                cleanup: vi.fn(),
            };
        });
        const propertyNames = ['firstname', 'lastname'];
        const { result } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(result.current.properties).toEqual({
                firstname: 'Initial',
                lastname: null,
            });
            expect(result.current.isLoading).toBe(false);
        });
        const updatedProperties = { firstname: null, lastname: 'Updated Value' };
        await waitFor(() => {
            if (capturedCallback) {
                capturedCallback?.(updatedProperties);
                expect(result.current.properties).toEqual(updatedProperties);
            }
        });
    });
    // This will become "should pass formatting options to fetchCrmProperties" in the next PR
    it('should pass formatting options to fetchCrmProperties', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
                lastname: 'Doe',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname', 'lastname'];
        const options = {
            propertiesToFormat: ['firstname'],
        };
        renderHook(() => useCrmProperties(propertyNames, options));
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function), options);
        });
    });
    it('should use default empty options when no options provided', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname'];
        const defaultOptions = {};
        renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledWith(['firstname'], expect.any(Function), defaultOptions);
        });
    });
    it('should not re-fetch when options object reference changes but content is the same', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname'];
        const initialOptions = { propertiesToFormat: ['firstname'] };
        const { rerender } = renderHook(({ options }) => useCrmProperties(propertyNames, options), { initialProps: { options: initialOptions } });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
        const newOptionsWithSameContent = { propertiesToFormat: ['firstname'] };
        rerender({ options: newOptionsWithSameContent });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
    });
    it('should re-fetch when options content actually changes', async () => {
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: vi.fn(),
        });
        const propertyNames = ['firstname'];
        const initialOptions = { propertiesToFormat: ['firstname'] };
        const { rerender } = renderHook(({ options }) => useCrmProperties(propertyNames, options), { initialProps: { options: initialOptions } });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
            expect(mockFetchCrmProperties).toHaveBeenLastCalledWith(['firstname'], expect.any(Function), initialOptions);
        });
        const newOptions = {
            propertiesToFormat: ['firstname'],
            formattingOptions: { dateFormat: 'yyyy-MM-dd' },
        };
        rerender({ options: newOptions });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(2);
            expect(mockFetchCrmProperties).toHaveBeenLastCalledWith(['firstname'], expect.any(Function), newOptions);
        });
    });
    it('should call cleanup function when component unmounts', async () => {
        const mockCleanup = vi.fn();
        mockFetchCrmProperties.mockResolvedValue({
            data: {
                firstname: 'John',
            },
            cleanup: mockCleanup,
        });
        const propertyNames = ['firstname'];
        const { unmount } = renderHook(() => useCrmProperties(propertyNames));
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
        unmount();
        expect(mockCleanup).toHaveBeenCalledTimes(1);
    });
    it('should call cleanup function when dependencies change', async () => {
        const mockCleanup1 = vi.fn();
        const mockCleanup2 = vi.fn();
        mockFetchCrmProperties
            .mockResolvedValueOnce({
            data: { firstname: 'John' },
            cleanup: mockCleanup1,
        })
            .mockResolvedValueOnce({
            data: { firstname: 'Jane' },
            cleanup: mockCleanup2,
        });
        const { rerender } = renderHook(({ propertyNames }) => useCrmProperties(propertyNames), { initialProps: { propertyNames: ['firstname'] } });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(1);
        });
        // Change dependencies to trigger cleanup
        rerender({ propertyNames: ['lastname'] });
        await waitFor(() => {
            expect(mockFetchCrmProperties).toHaveBeenCalledTimes(2);
            expect(mockCleanup1).toHaveBeenCalledTimes(1);
        });
    });
    it('should handle non-array propertyNames without crashing during stabilization', async () => {
        const errorMessage = 'Properties must be an array of strings';
        mockFetchCrmProperties.mockRejectedValue(new Error(errorMessage));
        const nonArrayPropertyNames = 2;
        const { result } = renderHook(() => 
        // @ts-expect-error - we are deliberately testing a bad type
        useCrmProperties(nonArrayPropertyNames));
        await waitFor(() => {
            expect(result.current.error).toBeInstanceOf(Error);
            expect(result.current.error?.message).toBe(errorMessage);
            expect(result.current.isLoading).toBe(false);
        });
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(2, expect.any(Function), {});
    });
});
