import { vi } from 'vitest';
// Set up the mock before importing the module
const mockFetchCrmProperties = vi.fn();
const mockSelf = {
    fetchCrmProperties: mockFetchCrmProperties,
};
// Mock the global self object
Object.defineProperty(global, 'self', {
    value: mockSelf,
    writable: true,
});
import { fetchCrmProperties } from "../../../crm/utils/fetchCrmProperties.js";
const DEFAULT_OPTIONS = {};
describe('fetchCrmProperties', () => {
    beforeEach(() => {
        vi.clearAllMocks();
    });
    it('successfully fetches CRM properties', async () => {
        const mockApiResponse = {
            data: {
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            },
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname', 'lastname'];
        const result = await fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS);
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function), DEFAULT_OPTIONS);
        expect(result).toEqual({
            data: {
                firstname: 'Test value for firstname',
                lastname: 'Test value for lastname',
            },
            cleanup: expect.any(Function),
        });
    });
    it('successfully fetches CRM properties with null values', async () => {
        const mockApiResponse = {
            data: {
                firstname: 'John',
                lastname: null,
                email: 'john@example.com',
                phone: null,
            },
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname', 'lastname', 'email', 'phone'];
        const result = await fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS);
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function), DEFAULT_OPTIONS);
        expect(result).toEqual({
            data: {
                firstname: 'John',
                lastname: null,
                email: 'john@example.com',
                phone: null,
            },
            cleanup: expect.any(Function),
        });
    });
    it('throws an error when response is not OK', async () => {
        const mockResponse = {
            ok: false,
            statusText: 'Not Found',
            json: vi.fn().mockResolvedValue({}),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname'];
        await expect(fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS)).rejects.toThrow('Failed to fetch CRM properties: Not Found');
    });
    it('throws an error when fetch fails', async () => {
        mockFetchCrmProperties.mockRejectedValue(new Error('Network error'));
        const propertyNames = ['firstname'];
        await expect(fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS)).rejects.toThrow('Network error');
    });
    it('throws an error if the response is not an object', async () => {
        const mockApiResponse = {
            data: 'Invalid response', // data should be an object
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname'];
        await expect(fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS)).rejects.toThrow('Invalid response format');
    });
    it('throws an error if response contains invalid property values', async () => {
        const mockApiResponse = {
            data: {
                firstname: 'John',
                lastname: 123, // Invalid: should be string or null
                email: 'john@example.com',
            },
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname', 'lastname', 'email'];
        await expect(fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS)).rejects.toThrow('Invalid response format');
    });
    it('passes the propertiesUpdatedCallback and allows it to be called', async () => {
        let capturedCallback;
        const mockApiResponse = {
            data: {
                firstname: 'Initial',
                lastname: 'Initial',
            },
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockImplementation((propertyNames, callback) => {
            capturedCallback = callback;
            return Promise.resolve(mockResponse);
        });
        const propertyNames = ['firstname', 'lastname'];
        const mockCallback = vi.fn();
        await fetchCrmProperties(propertyNames, mockCallback, DEFAULT_OPTIONS);
        expect(typeof capturedCallback).toBe('function');
        // Simulate the callback being called with new properties
        const updatedProps = { firstname: 'Updated', lastname: 'Updated' };
        if (capturedCallback) {
            capturedCallback(updatedProps);
        }
        expect(mockCallback).toHaveBeenCalledWith(updatedProps);
    });
    it('passes the propertiesUpdatedCallback and allows it to be called with null values', async () => {
        let capturedCallback;
        const mockApiResponse = {
            data: {
                firstname: 'Initial',
                lastname: null,
            },
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockImplementation((propertyNames, callback) => {
            capturedCallback = callback;
            return Promise.resolve(mockResponse);
        });
        const propertyNames = ['firstname', 'lastname'];
        const mockCallback = vi.fn();
        await fetchCrmProperties(propertyNames, mockCallback, DEFAULT_OPTIONS);
        expect(typeof capturedCallback).toBe('function');
        // Simulate the callback being called with new properties including null values
        const updatedProps = { firstname: null, lastname: 'Updated Value' };
        if (capturedCallback) {
            capturedCallback(updatedProps);
        }
        expect(mockCallback).toHaveBeenCalledWith(updatedProps);
    });
    it('passes formatting options to the underlying fetch function', async () => {
        const mockApiResponse = {
            data: {
                firstname: 'John',
                lastname: 'Doe',
            },
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname', 'lastname'];
        const options = {
            propertiesToFormat: ['firstname'],
            formattingOptions: {
                date: {
                    format: 'MM/dd/yyyy',
                },
                currency: {
                    addSymbol: true,
                },
            },
        };
        await fetchCrmProperties(propertyNames, vi.fn(), options);
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function), options);
    });
    it('preserves error handling with formatting options', async () => {
        mockFetchCrmProperties.mockRejectedValue(new Error('Network error'));
        const propertyNames = ['firstname'];
        const options = {
            propertiesToFormat: ['firstname'],
            formattingOptions: {
                date: {
                    format: 'MM/dd/yyyy',
                },
            },
        };
        await expect(fetchCrmProperties(propertyNames, vi.fn(), options)).rejects.toThrow('Network error');
        expect(mockFetchCrmProperties).toHaveBeenCalledWith(propertyNames, expect.any(Function), options);
    });
    it('preserves response validation with formatting options', async () => {
        const mockApiResponse = {
            data: 'Invalid response', // data should be an object
            cleanup: vi.fn(),
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname'];
        const options = {
            propertiesToFormat: 'all',
        };
        await expect(fetchCrmProperties(propertyNames, vi.fn(), options)).rejects.toThrow('Invalid response format');
    });
    it('returns cleanup function that can be called', async () => {
        const mockCleanup = vi.fn();
        const mockApiResponse = {
            data: {
                firstname: 'John',
            },
            cleanup: mockCleanup,
        };
        const mockResponse = {
            ok: true,
            json: vi.fn().mockResolvedValue(mockApiResponse),
        };
        mockFetchCrmProperties.mockResolvedValue(mockResponse);
        const propertyNames = ['firstname'];
        const result = await fetchCrmProperties(propertyNames, vi.fn(), DEFAULT_OPTIONS);
        expect(result.cleanup).toBe(mockCleanup);
        expect(typeof result.cleanup).toBe('function');
        // Verify cleanup can be called without errors
        result.cleanup();
        expect(mockCleanup).toHaveBeenCalledTimes(1);
    });
});
