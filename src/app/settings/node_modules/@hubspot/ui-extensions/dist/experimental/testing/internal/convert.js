import { KIND_COMPONENT, KIND_FRAGMENT, KIND_TEXT, } from '@remote-ui/core';
import { createElementNode } from "./element.js";
import { DuplicateTestIdError, InvalidFragmentPropArrayError, } from "./errors.js";
import { createFragmentNode } from "./fragment.js";
import { createTextNode } from "./text.js";
import { __hubSpotComponentRegistry } from "../../../shared/remoteComponents.js";
import { isRenderedTextNode } from "../type-utils.js";
import { EMPTY_RENDERED_CHILD_NODES } from "./constants.js";
import { asRenderedParentNode } from "./type-utils-internal.js";
/* eslint-disable @typescript-eslint/no-use-before-define */
/**
 * Converts a remote props object to a props object that can be attached to a rendered element node.
 *
 * @param document The document to use for creating new nodes.
 * @param componentName The name of the component to convert the props for.
 * @param remoteProps The remote props object to convert.
 * @returns The rendered props object.
 */
const convertRemoteProps = (document, componentName, remoteProps) => {
    if (typeof remoteProps !== 'object' || remoteProps == null) {
        return {};
    }
    const convertedProps = {};
    for (const [propName, remotePropValue] of Object.entries(remoteProps)) {
        if (propName === 'children') {
            // Skip over `children` props since we created nested nodes in our tree for children
            continue;
        }
        if (__hubSpotComponentRegistry.isComponentFragmentProp(componentName, propName)) {
            if (Array.isArray(remotePropValue)) {
                throw new InvalidFragmentPropArrayError(componentName, propName);
            }
            const fragmentNode = createFragmentNode(document);
            if (remotePropValue == null) {
                fragmentNode.childNodes = EMPTY_RENDERED_CHILD_NODES;
            }
            else if (typeof remotePropValue === 'string') {
                const text = remotePropValue;
                fragmentNode.text = text;
                fragmentNode.childNodes = [createTextNode(document, text)];
            }
            else if (remotePropValue.kind === KIND_FRAGMENT) {
                convertRemoteChildren(document, fragmentNode, remotePropValue);
            }
            convertedProps[propName] = fragmentNode;
        }
        else {
            convertedProps[propName] = remotePropValue;
        }
    }
    return convertedProps;
};
/**
 * Converts a remote child node to a rendered child node.
 *
 * @param document The document to use for creating new nodes.
 * @param remoteChild The remote child node to convert.
 *
 * @returns The rendered child node.
 */
const convertChildNode = (document, remoteChild) => {
    if (remoteChild.kind === KIND_TEXT) {
        return createTextNode(document, remoteChild);
    }
    else if (remoteChild.kind === KIND_COMPONENT) {
        const name = remoteChild.type;
        const props = convertRemoteProps(document, name, remoteChild.props);
        const elementNode = createElementNode(document, name, props);
        if (!__hubSpotComponentRegistry.isAllowedComponentName(name)) {
            document.addInvalidComponentName(name);
        }
        const { testId } = props;
        if (testId) {
            // If the element has a test ID we will put the element in a lookup map for
            // efficient queries using `findByTestId()`/`maybeFindByTestId()`.
            // First, we need to check if it is already in use and throw an error if it is.
            const existingElement = document.testIdToElementMap.get(testId);
            if (existingElement) {
                throw new DuplicateTestIdError({
                    testId,
                    previousElement: existingElement,
                    newElement: elementNode,
                });
            }
            // If the test ID is not already in use, we can add the element to the lookup map.
            document.testIdToElementMap.set(testId, elementNode);
        }
        convertRemoteChildren(document, elementNode, remoteChild);
        return elementNode;
    }
    else {
        throw new Error(`Illegal State. Unknown remote child. (${JSON.stringify(remoteChild)})`);
    }
};
/**
 * Converts the children of a remote parent node to our rendered child nodes.
 * After conversion, the rendered parent node will have its `childNodes` property set
 * to the converted child nodes.
 *
 * @param parentNode The rendered parent node to convert.
 * @param remoteParentNode The remote parent node to convert.
 */
const convertRemoteChildren = (document, parentNode, remoteParentNode) => {
    const remoteChildren = remoteParentNode.children;
    if (remoteChildren == null) {
        return;
    }
    if (typeof remoteChildren === 'string') {
        const text = remoteChildren;
        parentNode.text = text;
        parentNode.childNodes = [createTextNode(document, text)];
        return;
    }
    let text = null;
    const convertedChildNodes = [];
    let lastRenderedChild;
    for (const remoteChild of remoteChildren) {
        if (remoteChild.kind === KIND_TEXT) {
            const currentChildText = remoteChild.text;
            if (text == null) {
                text = currentChildText;
            }
            else {
                text += currentChildText;
            }
            if (lastRenderedChild && isRenderedTextNode(lastRenderedChild)) {
                // We normalize text nodes by combining consecutive text nodes into a single text node.
                lastRenderedChild.text += remoteChild.text;
                continue;
            }
        }
        const renderedChildNode = convertChildNode(document, remoteChild);
        convertedChildNodes.push(renderedChildNode);
        lastRenderedChild = renderedChildNode;
    }
    parentNode.text = text;
    parentNode.childNodes = convertedChildNodes;
};
/**
 * Converts a remote root node to a rendered root node. After conversion, the rendered root node will
 * have its `childNodes` property set to the converted child nodes.
 *
 * @param rootNode The rendered root node to convert.
 * @param remoteRoot The remote root node to convert.
 */
export const convertRemoteRoot = (rootNode, remoteRoot) => {
    const { document } = rootNode;
    convertRemoteChildren(document, asRenderedParentNode(rootNode), remoteRoot);
};
