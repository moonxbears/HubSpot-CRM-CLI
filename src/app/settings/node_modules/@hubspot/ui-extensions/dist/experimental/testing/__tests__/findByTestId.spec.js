import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { describe, expect, it } from 'vitest';
import { Alert, Button, ButtonRow, Text } from "../../../index.js";
import { createRenderer } from "../index.js";
import { ComponentMismatchedByTestIdError, ComponentNotFoundByTestIdError, FindInvalidComponentError, } from "../internal/errors.js";
describe('findByTestId()', () => {
    it('should find a component by testId', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "primary", testId: "primary-button", children: "Click me" }) }));
        const button = findByTestId(Button, 'primary-button');
        expect(button.props).toMatchObject({
            variant: 'primary',
            testId: 'primary-button',
        });
        expect(button.text).toEqual('Click me');
    });
    it('should find a component by testId among multiple components', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "secondary", testId: "button-1", children: "Button 1" }), _jsx(Button, { variant: "primary", testId: "button-2", children: "Button 2" }), _jsx(Button, { variant: "destructive", testId: "button-3", children: "Button 3" })] }));
        const button = findByTestId(Button, 'button-2');
        expect(button.props).toMatchObject({
            variant: 'primary',
            testId: 'button-2',
        });
        expect(button.text).toEqual('Button 2');
    });
    it('should find a nested component by testId', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", testId: "nested-button", children: "Nested Button" }) }) }));
        const button = findByTestId(Button, 'nested-button');
        expect(button.props).toMatchObject({
            variant: 'primary',
            testId: 'nested-button',
        });
        expect(button.text).toEqual('Nested Button');
    });
    it('should find different component types by their testIds', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", testId: "my-button", children: "Click me" }), _jsx(Alert, { title: "My Alert", testId: "my-alert" })] }));
        const button = findByTestId(Button, 'my-button');
        expect(button.props).toMatchObject({
            variant: 'primary',
            testId: 'my-button',
        });
        const alert = findByTestId(Alert, 'my-alert');
        expect(alert.props).toMatchObject({
            title: 'My Alert',
            testId: 'my-alert',
        });
    });
    it('should throw ComponentNotFoundByTestIdError when testId is not found', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "primary", testId: "existing-button", children: "Click me" }) }));
        expect(() => findByTestId(Button, 'non-existent-testid')).toThrow(ComponentNotFoundByTestIdError);
    });
    it('should throw ComponentNotFoundByTestIdError when component has no testId', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "primary", children: "Click me" }) }));
        expect(() => findByTestId(Button, 'some-testid')).toThrow(ComponentNotFoundByTestIdError);
    });
    it('should throw ComponentNotFoundByTestIdError with a helpful message when component has no testId', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "primary", children: "Click me" }) }));
        let error = null;
        try {
            findByTestId(Button, 'some-testid');
        }
        catch (_error) {
            error = _error;
        }
        expect(error).toBeInstanceOf(ComponentNotFoundByTestIdError);
        expect(error?.message).toMatchSnapshot();
    });
    it('should throw ComponentMismatchedByTestIdError when testId exists but component type does not match', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", testId: "my-element", children: "Click me" }), _jsx(Alert, { title: "My Alert", testId: "my-alert" })] }));
        expect(() => findByTestId(Alert, 'my-element')).toThrow(ComponentMismatchedByTestIdError);
    });
    it('should throw FindInvalidComponentError when target component is invalid', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "primary", testId: "my-button", children: "Click me" }) }));
        const MyFakeComponent = () => { };
        expect(() => findByTestId(MyFakeComponent, 'my-button')).toThrow(FindInvalidComponentError);
    });
    it('should work after re-rendering with new components', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "primary", testId: "button-1", children: "Button 1" }) }));
        let button = findByTestId(Button, 'button-1');
        expect(button.text).toEqual('Button 1');
        render(_jsx(_Fragment, { children: _jsx(Button, { variant: "secondary", testId: "button-2", children: "Button 2" }) }));
        button = findByTestId(Button, 'button-2');
        expect(button.text).toEqual('Button 2');
        expect(() => findByTestId(Button, 'button-1')).toThrow(ComponentNotFoundByTestIdError);
    });
    it('should handle testIds with special characters', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Button, { variant: "primary", testId: "button-with-dashes-123", children: "Button 1" }), _jsx(Button, { variant: "secondary", testId: "button_with_underscores", children: "Button 2" }), _jsx(Button, { variant: "destructive", testId: "button.with.dots", children: "Button 3" })] }));
        const button1 = findByTestId(Button, 'button-with-dashes-123');
        expect(button1.props.variant).toEqual('primary');
        const button2 = findByTestId(Button, 'button_with_underscores');
        expect(button2.props.variant).toEqual('secondary');
        const button3 = findByTestId(Button, 'button.with.dots');
        expect(button3.props.variant).toEqual('destructive');
    });
    it('should work with deeply nested components', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsx(_Fragment, { children: _jsx(ButtonRow, { children: _jsx(ButtonRow, { children: _jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", testId: "deeply-nested", children: "Deep Button" }) }) }) }) }));
        const button = findByTestId(Button, 'deeply-nested');
        expect(button.props).toMatchObject({
            variant: 'primary',
            testId: 'deeply-nested',
        });
    });
    it('should find component by testId regardless of rendering order', () => {
        const { render, findByTestId } = createRenderer('crm.record.tab');
        render(_jsxs(_Fragment, { children: [_jsx(Text, { testId: "text-1", children: "First" }), _jsx(Button, { variant: "primary", testId: "button-1", children: "Button" }), _jsx(Alert, { title: "Alert", testId: "alert-1" }), _jsx(Text, { testId: "text-2", children: "Second" })] }));
        const button = findByTestId(Button, 'button-1');
        expect(button.props.variant).toEqual('primary');
        const text1 = findByTestId(Text, 'text-1');
        expect(text1.text).toEqual('First');
        const text2 = findByTestId(Text, 'text-2');
        expect(text2.text).toEqual('Second');
        const alert = findByTestId(Alert, 'alert-1');
        expect(alert.props.title).toEqual('Alert');
    });
});
