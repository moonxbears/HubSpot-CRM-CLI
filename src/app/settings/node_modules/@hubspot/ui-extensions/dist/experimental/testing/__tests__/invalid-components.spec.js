import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useState } from 'react';
import { describe, expect, it } from 'vitest';
import { Alert, Button, ButtonRow, Text } from "../../../index.js";
import { createRenderer } from "../index.js";
import { InvalidComponentsError } from "../internal/errors.js";
import { createDeferred } from "../internal/utils/promise-utils.js";
const setTimeoutPromise = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
describe('handling invalid components', () => {
    it('should throw an error if initial render contains invalid components', () => {
        const { render } = createRenderer('crm.record.tab');
        function MyComponent() {
            return (_jsx("div", { children: _jsx("span", { children: _jsx(Button, { variant: "primary", children: "Click me!" }) }) }));
        }
        expect(() => render(_jsx(MyComponent, {}))).toThrow(InvalidComponentsError);
        let errorMessage;
        try {
            render(_jsx(MyComponent, {}));
        }
        catch (error) {
            errorMessage = String(error);
        }
        expect(errorMessage).toMatchSnapshot();
    });
    it('should throw an error if initial render contains invalid components inside a fragment', () => {
        const { render } = createRenderer('crm.record.tab');
        function MyComponent() {
            return (_jsxs(_Fragment, { children: [_jsx(ButtonRow, { children: _jsx(Button, { variant: "primary", overlay: _jsx("div", { children: "Overlay" }), children: "Click me!" }) }), _jsx(Alert, { title: "My Alert" })] }));
        }
        expect(() => render(_jsx(MyComponent, {}))).toThrow(InvalidComponentsError);
    });
    it('should throw an error if triggering an event results in an invalid component to be rendered', () => {
        const { render } = createRenderer('crm.record.tab');
        function Counter() {
            const [count, setCount] = useState(0);
            const handleClick = () => {
                setCount(count + 1);
            };
            return (_jsx(Button, { variant: "primary", onClick: handleClick, children: count === 0 ? 'Click me!' : _jsxs("div", { children: ["Clicked ", count, " times"] }) }));
        }
        const { find } = render(_jsx(Counter, {}));
        expect(find(Button).text).toEqual('Click me!');
        // Should throw an error because the component is invalid
        expect(() => {
            find(Button).trigger('onClick');
        }).toThrow(InvalidComponentsError);
    });
    it('should throw an error if the component is invalid after an asynchronous update', async () => {
        function AsyncCounter() {
            const [count, setCount] = useState(0);
            useEffect(() => {
                setTimeout(() => {
                    setCount((currentCount) => currentCount + 1);
                }, 10);
            }, []);
            return (_jsx(Button, { children: count === 0 ? 'Click me!' : _jsxs("div", { children: ["Clicked ", count, " times"] }) }));
        }
        const { render, find, waitFor } = createRenderer('crm.record.tab');
        render(_jsx(AsyncCounter, {}));
        expect(find(Button).text).toEqual('Click me!');
        await expect(waitFor(() => {
            expect(find(Button).text).toEqual('Clicked 1 times');
        })).rejects.toThrow(InvalidComponentsError);
    });
    it('should throw an error if the component is invalid after an asynchronous update when not using waitFor', async () => {
        const usePromise = (promise) => {
            const [isPending, setIsPending] = useState(true);
            useEffect(() => {
                setIsPending(true);
                promise
                    .then(() => setIsPending(false))
                    .catch(() => setIsPending(false));
            }, [promise]);
            return { isPending };
        };
        function AsyncCounter({ promise }) {
            const { isPending } = usePromise(promise);
            if (isPending) {
                return _jsx(Text, { children: "Loading..." });
            }
            // NOTE: `<div>` is an invalid component that should trigger an error after it is loaded.
            return _jsx("div", { children: "Loaded!" });
        }
        const loadingDeferred = createDeferred();
        const { render, find } = createRenderer('crm.record.tab');
        render(_jsx(AsyncCounter, { promise: loadingDeferred.promise }));
        expect(find(Text).text).toEqual('Loading...');
        loadingDeferred.resolve();
        await loadingDeferred.promise;
        // Wait another 5ms to be extra sure that the component has rerendered
        await setTimeoutPromise(5);
        expect(() => {
            find(Text);
        }).toThrow(InvalidComponentsError);
    });
});
