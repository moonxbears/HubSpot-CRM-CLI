import { __hubSpotComponentRegistry } from "../../../shared/remoteComponents.js";
import { isRenderedElementNode } from "../type-utils.js";
import { ComponentMismatchedByTestIdError, ComponentNotFoundByTestIdError, ComponentNotFoundError, FindInvalidComponentError, InvalidComponentsError, } from "./errors.js";
import { checkElementMatches } from "./match.js";
import { asRenderedParentNode } from "./type-utils-internal.js";
const addMatchToFindResult = (findResult, match, options) => {
    if (options.findFirstOnly) {
        findResult.match = match;
    }
    else {
        findResult.allMatches.push(match);
    }
};
/**
 * Recursive helper for finding elements in the rendered tree.
 * NOTE: The input `findResult` is mutated in place.
 *
 * @param parentNode The parent node to search in.
 * @param options The options for the find operation.
 * @param findResult The find result to mutate.
 */
const findInternalHelper = (parentNode, options, findResult) => {
    const { childNodes } = parentNode;
    const { targetComponent, matcher, findFirstOnly, findDirectChildrenOnly } = options;
    const targetComponentName = __hubSpotComponentRegistry.getComponentName(targetComponent);
    for (const childNode of childNodes) {
        if (!isRenderedElementNode(childNode)) {
            // Skip over non-element child nodes (just text nodes)
            continue;
        }
        if (childNode.name === targetComponentName &&
            checkElementMatches(childNode, matcher)) {
            // We found a match, so add it to the find result
            addMatchToFindResult(findResult, childNode, options);
            if (findFirstOnly) {
                return;
            }
        }
        // We only search in nested child nodes and fragment props if we're not only looking for children
        if (!findDirectChildrenOnly) {
            // Search for the component in the fragment props
            const { props } = childNode;
            const fragmentProps = __hubSpotComponentRegistry.getComponentFragmentPropNames(childNode.name);
            for (const fragmentPropName of fragmentProps) {
                const maybeFragment = props[fragmentPropName];
                // NOTE: As part of the conversion process of converting remote nodes to rendered nodes, we
                //       create a RenderedFragmentNode for each fragment prop and put that into the props object.
                if (maybeFragment) {
                    findInternalHelper(maybeFragment, options, findResult);
                    if (findFirstOnly && findResult.match) {
                        return;
                    }
                }
            }
            // Search for the component in the child
            findInternalHelper(childNode, options, findResult);
            if (findFirstOnly && findResult.match) {
                return;
            }
        }
    }
    return;
};
const validateComponent = (targetComponent, findMethodName) => {
    const targetComponentName = __hubSpotComponentRegistry.getComponentName(targetComponent);
    if (!targetComponentName) {
        throw new FindInvalidComponentError({
            findMethodName,
        });
    }
    return {
        targetComponentName,
    };
};
const validateRenderedDocument = (document) => {
    if (document.hasInvalidComponentNames()) {
        throw new InvalidComponentsError(document.rootNode);
    }
};
/**
 * Internal utility that centralizes finding elements in the rendered tree (including error handling).
 *
 * @param parentNode The parent node to search in.
 * @param options The options for the find operation.
 * @returns The find result.
 */
const findInternal = (parentNode, options) => {
    const { document } = parentNode;
    const { targetComponent, findMethodName, shouldThrowErrorIfNotFound } = options;
    const { targetComponentName } = validateComponent(targetComponent, findMethodName);
    validateRenderedDocument(document);
    // Initialize the find result that will be mutated in place
    const findResult = {
        match: null,
        allMatches: [],
    };
    // Run the internal find helper to recursively search the rendered tree
    findInternalHelper(asRenderedParentNode(parentNode), options, findResult);
    if (findResult.match === null && shouldThrowErrorIfNotFound) {
        throw new ComponentNotFoundError({
            findMethodName: options.findMethodName,
            parentNode: asRenderedParentNode(parentNode),
            componentName: targetComponentName,
        });
    }
    return findResult;
};
/**
 * Finds the first descendant element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first element node that matches the given component or `null` if no match is found.
 */
export const maybeFind = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: false,
        findMethodName: 'maybeFind',
        shouldThrowErrorIfNotFound: false,
    });
    return match;
};
/**
 * Finds the first descendant element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first element node that matches the given component.
 */
export const find = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: false,
        findMethodName: 'find',
        shouldThrowErrorIfNotFound: true,
    });
    return match;
};
/**
 * Finds all descendant element nodes that match the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns An array of element nodes that match the given component.
 */
export const findAll = (parentNode, targetComponent, matcher) => {
    const { allMatches } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: false,
        findDirectChildrenOnly: false,
        findMethodName: 'findAll',
        shouldThrowErrorIfNotFound: false,
    });
    return allMatches;
};
/**
 * Finds the first direct child element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first child element node that matches the given component.
 */
export const findChild = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: true,
        findMethodName: 'findChild',
        shouldThrowErrorIfNotFound: true,
    });
    return match;
};
/**
 * Finds the first direct child element node that matches the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns The first child element node that matches the given component.
 */
export const maybeFindChild = (parentNode, targetComponent, matcher) => {
    const { match } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: true,
        findDirectChildrenOnly: true,
        findMethodName: 'maybeFindChild',
        shouldThrowErrorIfNotFound: false,
    });
    return match;
};
/**
 * Finds all direct child element nodes that match the given component.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param matcher An optional matcher to filter the elements.
 * @returns An array of child element nodes that match the given component.
 */
export const findAllChildren = (parentNode, targetComponent, matcher) => {
    const { allMatches } = findInternal(parentNode, {
        targetComponent,
        matcher,
        findFirstOnly: false,
        findDirectChildrenOnly: true,
        findMethodName: 'findAllChildren',
        shouldThrowErrorIfNotFound: false,
    });
    return allMatches;
};
const findByTestIdHelper = (options) => {
    const { document, targetComponent, testId, findMethodName, shouldThrowErrorIfNotFound, } = options;
    const { targetComponentName } = validateComponent(targetComponent, findMethodName);
    validateRenderedDocument(document);
    const matchingElement = document.testIdToElementMap.get(testId);
    if (!matchingElement) {
        if (shouldThrowErrorIfNotFound) {
            throw new ComponentNotFoundByTestIdError({
                findMethodName,
                componentName: targetComponentName,
                testId,
                rootNode: document.rootNode,
            });
        }
        return null;
    }
    if (!matchingElement.isMatch(targetComponent)) {
        throw new ComponentMismatchedByTestIdError({
            findMethodName,
            actualComponentName: matchingElement.name,
            expectedComponentName: targetComponentName,
            testId,
            rootNode: document.rootNode,
        });
    }
    return matchingElement;
};
/**
 * Finds the first descendant element node that matches the given component and test ID.
 *
 * @param parentNode The parent node to search in.
 * @param targetComponent The component to find.
 * @param testId The test ID to find.
 * @returns The first element node that matches the given component and test ID.
 */
export const maybeFindByTestId = (document, targetComponent, testId) => {
    const maybeMatchingElement = findByTestIdHelper({
        document,
        targetComponent,
        testId,
        findMethodName: 'maybeFindByTestId',
        shouldThrowErrorIfNotFound: false,
    });
    return maybeMatchingElement;
};
export const findByTestId = (document, targetComponent, testId) => {
    const matchingElement = findByTestIdHelper({
        document,
        targetComponent,
        testId,
        findMethodName: 'findByTestId',
        shouldThrowErrorIfNotFound: true,
    });
    return matchingElement;
};
